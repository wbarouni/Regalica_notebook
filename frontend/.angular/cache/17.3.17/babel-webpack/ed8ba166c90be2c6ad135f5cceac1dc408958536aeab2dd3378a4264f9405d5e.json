{"ast":null,"code":"import { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport let ViewerService = /*#__PURE__*/(() => {\n  class ViewerService {\n    constructor() {\n      this.currentDocumentSubject = new BehaviorSubject(null);\n      this.currentDocument$ = this.currentDocumentSubject.asObservable();\n      this.highlightedSpansSubject = new BehaviorSubject([]);\n      this.highlightedSpans$ = this.highlightedSpansSubject.asObservable();\n      this.currentPageSubject = new BehaviorSubject(1);\n      this.currentPage$ = this.currentPageSubject.asObservable();\n    }\n    /**\n     * Charge un document dans le viewer\n     */\n    loadDocument(document) {\n      this.currentDocumentSubject.next(document);\n      this.currentPageSubject.next(1);\n      this.clearHighlights();\n    }\n    /**\n     * Obtient le document actuellement affiché\n     */\n    getCurrentDocument() {\n      return this.currentDocumentSubject.value;\n    }\n    /**\n     * Change la page courante\n     */\n    setCurrentPage(page) {\n      const doc = this.getCurrentDocument();\n      if (doc && doc.pages && page >= 1 && page <= doc.pages.length) {\n        this.currentPageSubject.next(page);\n      }\n    }\n    /**\n     * Obtient la page courante\n     */\n    getCurrentPage() {\n      return this.currentPageSubject.value;\n    }\n    /**\n     * Fait défiler vers un span spécifique et le met en surbrillance avec Range DOM précis\n     */\n    scrollToSpan(docId, page, start, end, chunkId) {\n      const doc = this.getCurrentDocument();\n      if (!doc || doc.id !== docId) {\n        console.warn('ViewerService: Document not loaded or ID mismatch:', docId);\n        return;\n      }\n      const request = {\n        docId,\n        page,\n        spanStart: start,\n        spanEnd: end,\n        chunkId\n      };\n      // Changer de page si nécessaire\n      if (page && page !== this.getCurrentPage()) {\n        this.setCurrentPage(page);\n      }\n      // Ajouter le highlight\n      this.addHighlight(request);\n      // Scroll vers l'élément après un court délai pour permettre le rendu\n      setTimeout(() => {\n        this.performDOMRangeScroll(request);\n      }, 150);\n    }\n    /**\n     * Ajoute un highlight à la liste\n     */\n    addHighlight(request) {\n      const currentHighlights = this.highlightedSpansSubject.value;\n      // Éviter les doublons\n      const exists = currentHighlights.some(h => h.docId === request.docId && h.page === request.page && h.spanStart === request.spanStart && h.spanEnd === request.spanEnd);\n      if (!exists) {\n        this.highlightedSpansSubject.next([...currentHighlights, request]);\n      }\n    }\n    /**\n     * Effectue le scroll physique vers l'élément avec Range DOM précis\n     */\n    performDOMRangeScroll(request) {\n      try {\n        // Chercher d'abord par attribut data (méthode préférée)\n        const selector = `[data-span-start=\"${request.spanStart}\"][data-span-end=\"${request.spanEnd}\"]`;\n        let targetElement = document.querySelector(selector);\n        if (targetElement) {\n          this.scrollToElementAndHighlight(targetElement, request);\n          return;\n        }\n        // Fallback: utiliser Range API pour trouver le texte par position\n        const contentElement = document.querySelector('.viewer-content, .document-content, .page-content');\n        if (!contentElement) {\n          console.warn('ViewerService: No content element found for scrolling');\n          return;\n        }\n        const range = this.createRangeFromCharacterPositions(contentElement, request.spanStart, request.spanEnd);\n        if (range) {\n          targetElement = this.createHighlightElement(range, request);\n          if (targetElement) {\n            this.scrollToElementAndHighlight(targetElement, request);\n          }\n        } else {\n          // Fallback final: scroll proportionnel\n          this.performProportionalScroll(contentElement, request);\n        }\n      } catch {\n        console.error(\"ViewerService: Error during DOM range scroll:\", \"Unknown error\");\n        // Fallback silencieux\n        const contentElement = document.querySelector('.viewer-content, .document-content');\n        if (contentElement) {\n          this.performProportionalScroll(contentElement, request);\n        }\n      }\n    }\n    /**\n     * Crée un Range DOM à partir de positions de caractères\n     */\n    createRangeFromCharacterPositions(container, start, end) {\n      const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null);\n      let currentPos = 0;\n      let startNode = null;\n      let startOffset = 0;\n      let endNode = null;\n      let endOffset = 0;\n      let node;\n      while (node = walker.nextNode()) {\n        const textLength = node.textContent?.length || 0;\n        if (!startNode && currentPos + textLength >= start) {\n          startNode = node;\n          startOffset = start - currentPos;\n        }\n        if (!endNode && currentPos + textLength >= end) {\n          endNode = node;\n          endOffset = end - currentPos;\n          break;\n        }\n        currentPos += textLength;\n      }\n      if (startNode && endNode) {\n        const range = document.createRange();\n        range.setStart(startNode, Math.max(0, startOffset));\n        range.setEnd(endNode, Math.min(endNode.textContent?.length || 0, endOffset));\n        return range;\n      }\n      return null;\n    }\n    /**\n     * Crée un élément de surbrillance à partir d'un Range\n     */\n    createHighlightElement(range, request) {\n      try {\n        // Créer un span de surbrillance\n        const highlightSpan = document.createElement('span');\n        highlightSpan.className = 'viewer-highlight-span';\n        highlightSpan.setAttribute('data-span-start', request.spanStart.toString());\n        highlightSpan.setAttribute('data-span-end', request.spanEnd.toString());\n        if (request.chunkId) {\n          highlightSpan.setAttribute('data-chunk-id', request.chunkId);\n        }\n        // Entourer le contenu du range\n        range.surroundContents(highlightSpan);\n        return highlightSpan;\n      } catch {\n        // Si surroundContents échoue (range complexe), utiliser extractContents\n        try {\n          const contents = range.extractContents();\n          const highlightSpan = document.createElement('span');\n          highlightSpan.className = 'viewer-highlight-span';\n          highlightSpan.setAttribute('data-span-start', request.spanStart.toString());\n          highlightSpan.setAttribute('data-span-end', request.spanEnd.toString());\n          if (request.chunkId) {\n            highlightSpan.setAttribute('data-chunk-id', request.chunkId);\n          }\n          highlightSpan.appendChild(contents);\n          range.insertNode(highlightSpan);\n          return highlightSpan;\n        } catch (_innerError) {\n          console.warn(\"ViewerService: Could not create highlight element:\", _innerError);\n          return null;\n        }\n      }\n    }\n    /**\n     * Scroll vers un élément et applique l'animation de surbrillance\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    scrollToElementAndHighlight(element, request) {\n      element.scrollIntoView({\n        behavior: 'smooth',\n        block: 'center',\n        inline: 'nearest'\n      });\n      // Ajouter les classes de surbrillance\n      element.classList.add('viewer-highlight-active', 'viewer-highlight-flash');\n      // Utiliser _request pour éviter l'erreur 'defined but never used'\n      // Supprimer l'animation flash après 2 secondes\n      setTimeout(() => {\n        element.classList.remove('viewer-highlight-flash');\n      }, 2000);\n    }\n    /**\n     * Scroll proportionnel basé sur la position du caractère\n     */\n    performProportionalScroll(contentElement, request) {\n      const textContent = contentElement.textContent || '';\n      const totalLength = textContent.length;\n      if (totalLength > 0) {\n        const scrollRatio = request.spanStart / totalLength;\n        const scrollTop = Math.max(0, scrollRatio * contentElement.scrollHeight);\n        contentElement.scrollTo({\n          top: scrollTop,\n          behavior: 'smooth'\n        });\n      }\n    }\n    /**\n     * Efface tous les highlights\n     */\n    clearHighlights() {\n      this.highlightedSpansSubject.next([]);\n    }\n    /**\n     * Supprime un highlight spécifique\n     */\n    removeHighlight(request) {\n      const currentHighlights = this.highlightedSpansSubject.value;\n      const filtered = currentHighlights.filter(h => !(h.docId === request.docId && h.page === request.page && h.spanStart === request.spanStart && h.spanEnd === request.spanEnd));\n      this.highlightedSpansSubject.next(filtered);\n    }\n    /**\n     * Vérifie si un span est actuellement en surbrillance\n     */\n    isHighlighted(docId, page, spanStart, spanEnd) {\n      const highlights = this.highlightedSpansSubject.value;\n      return highlights.some(h => h.docId === docId && h.page === page && h.spanStart === spanStart && h.spanEnd === spanEnd);\n    }\n    /**\n     * Obtient les highlights pour la page courante\n     */\n    getHighlightsForCurrentPage() {\n      const currentPage = this.getCurrentPage();\n      const doc = this.getCurrentDocument();\n      if (!doc) return [];\n      return this.highlightedSpansSubject.value.filter(h => h.docId === doc.id && h.page === currentPage);\n    }\n    static {\n      this.ɵfac = function ViewerService_Factory(t) {\n        return new (t || ViewerService)();\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: ViewerService,\n        factory: ViewerService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return ViewerService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}