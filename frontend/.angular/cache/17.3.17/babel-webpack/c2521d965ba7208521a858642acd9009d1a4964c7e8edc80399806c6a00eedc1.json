{"ast":null,"code":"import _asyncToGenerator from \"/home/ubuntu/Regalica_notebook/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BehaviorSubject } from 'rxjs';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let RagService = /*#__PURE__*/(() => {\n  class RagService {\n    constructor(http) {\n      this.http = http;\n      this.apiUrl = `${environment.apiBaseUrl}/rag`;\n      this.messagesSubject = new BehaviorSubject([]);\n      this.messages$ = this.messagesSubject.asObservable();\n      this.loadingSubject = new BehaviorSubject(false);\n      this.loading$ = this.loadingSubject.asObservable();\n    }\n    /**\n     * Recherche des candidats pour une requête\n     */\n    searchCandidates(query, topK = 50, lang) {\n      const body = {\n        query,\n        top_k: topK\n      };\n      if (lang) body.lang = lang;\n      return this.http.post(`${this.apiUrl}/query`, body);\n    }\n    /**\n     * Pose une question et obtient une réponse complète\n     */\n    askQuestion(query, topK = 50, lang) {\n      const body = {\n        query,\n        top_k: topK\n      };\n      if (lang) body.lang = lang;\n      this.loadingSubject.next(true);\n      const request = this.http.post(`${this.apiUrl}/answer`, body);\n      // Mettre à jour le loading state quand la requête se termine\n      request.subscribe({\n        next: () => this.loadingSubject.next(false),\n        error: () => this.loadingSubject.next(false)\n      });\n      return request;\n    }\n    /**\n     * Ajoute un message utilisateur au chat\n     */\n    addUserMessage(content) {\n      const messageId = this.generateMessageId();\n      const message = {\n        id: messageId,\n        role: 'user',\n        content,\n        timestamp: new Date()\n      };\n      const currentMessages = this.messagesSubject.value;\n      this.messagesSubject.next([...currentMessages, message]);\n      return messageId;\n    }\n    /**\n     * Ajoute une réponse de l'assistant au chat\n     */\n    addAssistantMessage(content, sources, confidence, stats) {\n      const messageId = this.generateMessageId();\n      const message = {\n        id: messageId,\n        role: 'assistant',\n        content,\n        sources,\n        confidence,\n        timestamp: new Date(),\n        processing_time_ms: stats?.total_processing_time_ms,\n        lang: stats?.lang_detected\n      };\n      const currentMessages = this.messagesSubject.value;\n      this.messagesSubject.next([...currentMessages, message]);\n      return messageId;\n    }\n    /**\n     * Pose une question complète (ajoute les messages et fait l'appel API)\n     */\n    chatWithRag(_x) {\n      var _this = this;\n      return _asyncToGenerator(function* (query, topK = 50, lang) {\n        // Ajouter le message utilisateur\n        _this.addUserMessage(query);\n        try {\n          // Faire l'appel API\n          const response = yield _this.askQuestion(query, topK, lang).toPromise();\n          if (response) {\n            // Ajouter la réponse de l'assistant\n            _this.addAssistantMessage(response.answer, response.sources, response.confidence, response.stats);\n          }\n        } catch (error) {\n          console.error('Erreur lors de la question RAG:', error);\n          // Ajouter un message d'erreur\n          _this.addAssistantMessage('Désolé, une erreur est survenue lors du traitement de votre question. Veuillez réessayer.', [], 0);\n        }\n      }).apply(this, arguments);\n    }\n    /**\n     * Efface l'historique des messages\n     */\n    clearMessages() {\n      this.messagesSubject.next([]);\n    }\n    /**\n     * Obtient les statistiques RAG\n     */\n    getStats() {\n      return this.http.get(`${this.apiUrl}/stats`);\n    }\n    /**\n     * Génère un ID unique pour les messages\n     */\n    generateMessageId() {\n      return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n    /**\n     * Formate une citation pour l'affichage\n     */\n    formatCitation(source) {\n      return `${source.title} (page ${source.page})`;\n    }\n    /**\n     * Extrait les citations d'un texte\n     */\n    extractCitations(text) {\n      const citationRegex = /\\[([^\\]]+)#([^:]+):([^\\]]+)\\]/g;\n      const citations = [];\n      let match;\n      while ((match = citationRegex.exec(text)) !== null) {\n        citations.push({\n          title: match[1],\n          page: match[2],\n          span: match[3],\n          citation: match[0]\n        });\n      }\n      return {\n        text,\n        citations\n      };\n    }\n    static {\n      this.ɵfac = function RagService_Factory(t) {\n        return new (t || RagService)(i0.ɵɵinject(i1.HttpClient));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: RagService,\n        factory: RagService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return RagService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}