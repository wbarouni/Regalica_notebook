{"ast":null,"code":"import _asyncToGenerator from \"/home/ubuntu/Regalica_notebook/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BehaviorSubject, firstValueFrom } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let AppConfigService = /*#__PURE__*/(() => {\n  class AppConfigService {\n    constructor(http) {\n      this.http = http;\n      this.configSubject = new BehaviorSubject(null);\n      this.config$ = this.configSubject.asObservable();\n      this.defaultConfig = {\n        backendBaseUrl: 'http://localhost:8080',\n        maxUploadSizeMb: 10,\n        features: {\n          mindmap: true,\n          podcast: true,\n          export: true\n        }\n      };\n    }\n    /**\n     * Charge la configuration depuis le backend au démarrage de l'application\n     */\n    loadConfig() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        try {\n          // Essayer de charger depuis le backend\n          const config = yield firstValueFrom(_this.http.get('/api/config'));\n          // Valider et normaliser la configuration\n          const validatedConfig = _this.validateConfig(config);\n          _this.configSubject.next(validatedConfig);\n          return validatedConfig;\n        } catch (error) {\n          console.warn('Failed to load config from backend, using defaults:', error);\n          // Fallback vers la configuration par défaut\n          _this.configSubject.next(_this.defaultConfig);\n          return _this.defaultConfig;\n        }\n      })();\n    }\n    /**\n     * Obtient la configuration actuelle de manière synchrone\n     */\n    getConfig() {\n      return this.configSubject.value || this.defaultConfig;\n    }\n    /**\n     * Obtient l'URL de base du backend\n     */\n    getBackendBaseUrl() {\n      return this.getConfig().backendBaseUrl;\n    }\n    /**\n     * Vérifie si une fonctionnalité est activée\n     */\n    isFeatureEnabled(feature) {\n      return this.getConfig().features[feature];\n    }\n    /**\n     * Obtient la taille maximale d'upload en MB\n     */\n    getMaxUploadSizeMb() {\n      return this.getConfig().maxUploadSizeMb;\n    }\n    /**\n     * Valide et normalise la configuration reçue\n     */\n    validateConfig(config) {\n      return {\n        backendBaseUrl: this.validateUrl(config.backendBaseUrl) || this.defaultConfig.backendBaseUrl,\n        maxUploadSizeMb: this.validateNumber(config.maxUploadSizeMb, 1, 1000) || this.defaultConfig.maxUploadSizeMb,\n        features: {\n          mindmap: Boolean(config.features?.mindmap ?? this.defaultConfig.features.mindmap),\n          podcast: Boolean(config.features?.podcast ?? this.defaultConfig.features.podcast),\n          export: Boolean(config.features?.export ?? this.defaultConfig.features.export)\n        }\n      };\n    }\n    /**\n     * Valide une URL\n     */\n    validateUrl(url) {\n      if (typeof url !== 'string') return null;\n      try {\n        new URL(url);\n        return url.replace(/\\/$/, ''); // Supprimer le slash final\n      } catch {\n        return null;\n      }\n    }\n    /**\n     * Valide un nombre dans une plage\n     */\n    validateNumber(value, min, max) {\n      const num = Number(value);\n      if (isNaN(num) || num < min || num > max) return null;\n      return num;\n    }\n    static {\n      this.ɵfac = function AppConfigService_Factory(t) {\n        return new (t || AppConfigService)(i0.ɵɵinject(i1.HttpClient));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: AppConfigService,\n        factory: AppConfigService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return AppConfigService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}